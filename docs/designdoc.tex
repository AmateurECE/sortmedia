%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NAME:             designdoc.tex
%
% AUTHOR:           Ethan D. Twardy <edtwardy@mtu.edu>
%
% DESCRIPTION:      Design Document for the project.
%
% CREATED:          05/15/2019
%
% LAST EDITED:      09/09/2019
%%%

\documentclass{designdoc}

\begin{document}
\section{Introduction}
\textit{SortMedia} is a program used to enumerate and restructure a group of
media files on a filesystem. Taking as an argument the path of a directory to
organize, the application recursively searches the directory for media files,
performing a number of operations on each to ensure that they conform to some
statically provided scheme.

The needs of this kind of program have a tendency to change frequently, so the
goal of this design is to be as versatile as possible.

\hypertarget{sec:axesOfChange}{\section{Axes of Change}}
An \textit{Axis of Change} for software is a reason for the code to undergo
some change as a result of a requirements change. It's often useful to predict
the axes of change that a project has before beginning its design. The
SortMedia project will be designed with the following axes of change in mind:

\subsection{Adding New Organizational Schemas}
An Organizational Schema is a set of rules that dictate the organization of
media files on the filesystem, as well as the metadata that they contain. The
schema that I prefer has changed slightly over the years, and is likely to
change again.

\subsection{Adding New Media File Types}
There are many types of media files. It's not reasonable to support all of them
from the beginning. The design shall make it easy to incorporate new media file
types into the project.

\subsection{Adding New File Operations to an Organizational Schema}
Separate from the organizational schema are the file operations. These are
rules that dictate how a change is performed to a file. With new Organizational
Schemas naturally comes the need for new File Operations.

\subsection{Exposing Greater Amounts of Configuration via the Command Line
  Interface}
Due to the nature of the design, as more child classes become available for
performing new or different functions per the axes of change outlined above,
the command line interface will also allow expansion to expose greater amounts
of configuration to the user. This will be accomplished in part via the
abundance of Factor Pattern methods in the design. These methods may be moved
to their own class, which can each then be probed and extended to determine its
functionality during the verification of runtime arguments, and also to provide
helpful messages to the user. There will also be a high degree of segregation
between the classes whose responsibility includes the command line interface
itself and those that use the arguments provided thereby, achieved using the
methods explained previously and creative use of the Dependency Injection
idiom.

\section{Isolation of Cross-Cutting Concerns}
Cross-cutting concerns are a major threat to the robustness and maintainability
of Object-Oriented designs. This application has two major concerns that meet
these requirements:
\begin{enumerate}
\item Logging
\item Configuration
\end{enumerate}
Logging is fairly insulated from change by its nature, but Configuration is
listed as part of the Axes of Change, so special care must be taken to prevent
\textit{Rigidity} as a result of change in the Configuration class(es).

To do this, the application will take on a ``flat'' hierarchy. Main will be
responsible for constructing (either directly or via a construction pattern,
e.g. Factory) the dependencies used by classes in the program. Furthermore,
both of these responsibilities will be restricted to particular classes. See
the architecture document for more information.

\section{Behavior and the Requirements}
The Axes of Change granted by this design allow the application to be
completely reconfigurable as the needs of the application change. Because
of this, requirements are subject to change without notice, and the behavior
of the application may also change to reflect.

\section{Software Requirements}
This section outlines the requirements of the software. From this point
forward, \emph{the Software} shall refer to the software product contained
herein.

\swrequirement{Name}
The executable binary program generated by the Software shall be named
\texttt{SortMedia}.

\swrequirement{Basic Usage}
The usage of the software is given below:

\begin{verbatim}
  Usage: SortMedia <rootDirectoryOfLibrary>
\end{verbatim}

\swrequirement{Atomic Transactions}
The Software shall use a design pattern for organizing Media files that allows
for "atomic" transactions. That is, a file may at any time be in one of two
states:
\begin{enumerate}
\item Organized
\item Unorganized
\end{enumerate}
In this way, intermediate changes to any file may be reverted in the case of
an error.

\swrequirement{Runtime Phases}
On every invocation, the Software shall perform its logic in two phases:
\begin{enumerate}
\item \textit{Initialization}: The Software enumerates the library to determine
  a list of files and that the library is a good candidate for
  \textit{Organization}.
\item \textit{Organization}: The Software shall apply rules to organize the
  media files in the library.
\end{enumerate}

\swrequirement{Initialization}
On initialization, the Software shall enumerate the library to determine the
list of media files to apply organization to, and also to determine if the
library is a good candidate for \textit{Organization}.

\swrequirement{Organization}
The Software shall organize all media files located during Initialization
based on the organizational scheme. This organizational scheme is subject to
change, as specified in \hyperlink{sec:axesOfChange}{Axes Of Change}. The
current scheme of organization is as follows:
\begin{enumerate}
\item Files ending with extension ".mp3", ".m4a" and ".flac" shall first be
  read to ensure that they contain tags for Artist, Album, Track Name and Track
  Number. They will then be renamed to the format (using C's printf style)
  ``\%2d \%s.\%s'', Track Number, Song name (where all non-alphanumeric
  characters in the name are replaced with an underscore '\_'), Extension. They
  will then be moved to a subdirectory of the library root with the structure
  \texttt{<rootOfLibrary>/<Artist>/<Album>/}.
\end{enumerate}

\swrequirement{Logging}
The Software shall perform logging to both a file and the stdout/stderr file
descriptors. The Software shall specify three levels of log messages, listed
in order of increasing severity:
\begin{enumerate}
\item \texttt{INFO}: Messages that occur during the normal operation of the
  Software.
\item \texttt{WARNING}: Messages that occur as a result of a condition that
  indicates a potentially unstable context, but does not immediately result
  in an \textit{Error State}.
\item \texttt{ERROR}: Messages that occur because the Software has entered an
  \textit{Error State}.
\end{enumerate}
The Software shall perform message logging (by default) as follows:
\begin{enumerate}
\item \texttt{INFO} messages shall be fed to the stdout file descriptor.
\item \texttt{WARNING} and \texttt{ERROR} messages shall be fed to the stderr
  file descriptor.
\end{enumerate}

\swrequirement{Error Handling}
During abnormal operation of the Software, the Software may enter an
\textit{Error State}. There are two kinds of \textit{Error States}.
\begin{enumerate}
\item \textit{Fatal Error}: Results in the termination of the program. This
  state occurs as a result of an unrecoverable condition that was encountered
  during the operation of the Software.
\item \textit{Non-Fatal Error}: Usually occurs as a result of a failure while
  applying a single atomic change to a Media File. Causes the Software to
  revert all previous modifications to the current Media File.
\end{enumerate}

\section{Feature Wish-List}
This section is a wish-list of features for the software to support. Some of
these features may not ever be implemented.
\begin{enumerate}
\item Specify verbosity in command line args. Three levels:
  \begin{enumerate}
  \item \textit{0}: No messages. Fatal errors are reported by non-zero return
    code.
  \item \textit{1}: Only WARNING and ERROR messages are printed.
  \item \textit{2 (default)}: WARNING, ERROR, and INFO messages are printed.
  \end{enumerate}
\item Specify stdout/stderr vs log file logging in command line args. Also
  specify path of log file.
\item Support more than one kind of library. Specify library type on command
  line.
\item Specify regular expressions, lists, globs, etc. for file types that
  the locator is allowed to include in its return. This overrides the file
  types that are included by default based on the library type.
\item Software can look up metadata and/or fingerprint media files to determine
  all relevant embedded metadata.
\item Software can be multithreaded to organize libraries faster. This,
  unfortunately, should still require all filesystem accesses and stream writes
  to be performed sequentially (in some fashion).
\item Software shall be able to add, modify, or delete embedded album artwork,
  in addition to downloading it from an online repository if it does not yet
  exist. This feature must play nicely with non-embedded local artwork (in the
  same directory).
\item Shall eventually delete (or at least ask to delete) files that don't
  belong in the library.
\item Shall delete a directory if a move/delete operation has rendered that
  directory empty.
\item Shall be able to open a file and determine its format by its contents,
  not by its file extension.
\item Shall allow the user to dynamically configure the organizational scheme
  of the application from the command line by specifying individual policies to
  apply to files that meet certain criteria.
\item Shall be able to recognize and correctly organize compilation albums.
\end{enumerate}
\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
